# Argus Security Model
Argus investigates potentially hostile repositories. A security tool without a strict internal security model is unsafe by default. This document explains the Argus defense model and its limits.

## Why Argus Needs Its Own Security Model
Argus processes untrusted input from:
- Repository contents
- File paths emitted by tools
- Tool-call arguments generated by LLMs

Without strict boundaries, an analyzed repository could trick the toolchain into reading outside scope, following hostile symlinks, or invoking unsafe subprocess behavior.

## Threat Model
Assumption: the target repository can be malicious.

Adversary goals include:
- Escaping the allowed path root
- Triggering reads of sensitive host files
- Forcing unsafe subprocess behavior
- Polluting logs to hide actions

Argus defends by constraining tool capabilities and validating every path before execution.

## Defense-in-Depth: 4 Sandbox Layers
1. **Capability restriction**  
   Tools are read-only by design: no writes, no code execution, no network from tools.
2. **Canonical path validation**  
   Paths are normalized and resolved before use.
3. **Symlink escape prevention**  
   Resolved path must stay under configured project root.
4. **Auditable execution trail**  
   Every call and result state is logged for review and incident response.

## Path Validation Algorithm
1. Receive user/model tool argument path.
2. Resolve to absolute path relative to configured root.
3. Canonicalize path using symlink-aware resolution.
4. Canonicalize sandbox root once.
5. Enforce `resolvedPath` has `resolvedRoot` as strict prefix.
6. Reject on any mismatch, resolution error, or traversal attempt.
7. Execute only after successful validation.

This blocks common traversal patterns (`../`, mixed separators, nested symlink pivots).

## Symlink Attack Scenarios
### Scenario A: In-repo symlink to `/etc`
Attack: `repo/logs -> /etc` then request `logs/passwd`  
Defense: resolved path canonicalizes to `/etc/passwd`, fails root-prefix check.

### Scenario B: Nested symlink chain
Attack: multiple symlinks hide escape target  
Defense: canonicalization resolves full chain before prefix enforcement.

### Scenario C: Path normalization tricks
Attack: encoded separators or `a/../../b` patterns  
Defense: cleaned absolute path and canonicalized target are both validated.

## Subprocess Isolation
Argus subprocess calls are constrained:
- Minimal argument surfaces
- Read-only command classes (`rg`, `fd/find`, `git log`)
- `--no-follow` where applicable to reduce symlink surprises
- Environment hardening features such as `GIT_CEILING_DIRECTORIES` for `git`

## Audit Trail
Argus logs:
- Tool name and parameters (sanitized as needed)
- Validation outcomes
- Execution status and errors
- Timing/timeout outcomes

Why this matters:
- Reproducibility for findings
- Forensic traceability
- Faster debugging of false positives and sandbox denials

## Explicit Non-Goals
Argus deliberately does **not** do the following in tool execution mode:
- Execute code from the analyzed repository
- Write files into the target repository or host system
- Allow tool-level network access

These non-goals keep investigation deterministic and reduce blast radius.
